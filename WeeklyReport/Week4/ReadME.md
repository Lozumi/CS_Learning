## 一、C语言基础复习

对部分知识点查漏补缺。

### （一）C语言基本数据类型

- \_Bool类型 P48
- 可移植类型：`stdint.h`和`inttypes.h` P48
  - `stdin.h`提供可移植的类型名，定义了精确宽度整数类型和最快最小宽度类型。
  - `inttype.h`提供相应的输入和输出，提供字符串宏来显示可以值类型，为printf()等函数提供转换说明。
- 十六进制表示浮点型常量 P50
  - 在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂。
  - 注意，给未在函数原型中显式说明参数类型的函数传递参数时，C编译器会把float类型的值自动转换成double类型。

### （二）数组和指针

- 数组
  - 初始化数组
    计算数组大小时，sizeof后可直接接变量，不需要加括号。

    ```c
    int days[] = {1, 2, 3, 4, 5};
    printf("%d %d", sizeof days, sizeof days[1]);
    ```
  
- 指定初始化器

- 指定数组的大小
  - 在定义数组时，必须明确确定数组的大小
  - 在C99新增变长数组前，数组的大小必须是整型常量，包括由整形常量组成的表达式
  
- 多维数组
  - 多维数组的元素按顺序存储
  
  - 二维数组的初始化
    - 可以省略行数，不能省略列数。
    
      ```c
      int arr1[4][5] = {
              {1, 1, 1, 1, 1},
              {2, 2, 2, 2, 2},
              {3, 3, 3, 3, 3},
              {4, 4, 4, 4, 4}}; // 正确而完整
      int arr2[4][5] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4}; // 正确而省略
      int arr3[][5] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4};  // 正确而省略
      int arr3[4][] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4};  // 错误而省略
      ```
  
- 数组与指针

- 指针与多维数组
	- 指向多维数组的指针
	  声明pz为指向一个内含两个int类型值的数组：
	
	  ```c
	  int (* pz)[2];// []的优先级高于*，应使pz为指针，然后定义其指向含两个int类型值的数组。
	  int arr_2d[4][2] = { { 1, 2}, { 3, 4}, { 5, 6}, { 7, 8} };
	  pz = arr_2d;
	  ```
	
	  
	
	应注意的是，可以用数组表示法或指针表示法来表示一个数组元素。**既可以使用数组名，也可以使用指针名。** 例如：
	```c
	arr_2d[m][n] == *(*(arr_2d + m) + n);
	pz[m][n] == *(*(pz + m) + n);
	```
	换言之，C把数组解释为该数组首元素的地址，**数组名与指向该数组首元素的指针等价**。
	- 函数与数组
		- C语言不能把整个数组作为参数传递给函数，但是可以传递数组的地址，然后函数可以使用传入的地址操控原始数组。在被调函数中可以使用数组表示法或指针表示法，无论哪种表示法实际上使用的都是指针变量。
		
		- 函数传递多维数组的方式是**把数组名传递给类型匹配的指针形参**。指针形参声明时需要指定除了第1个维度的所有维度，而第1个维度的带下通常作为第2个参数。声明函数的形参有两种方式：
		
		  ```c
		  void somefunction( int (* pz)[4], int rows);
		  void somefunction( int pz[][4], int rows);// 第一个空的方括号表明pz是一个指针
		  ```
### （三）字符串和字符串函数
- 定义字符串
	- 字符串字面量（字符串常量）
	  - 属于静态存储类别，只会被存储一次，在整个程序的生命期内存在，类似静态变量，存储在静态存储区。
	
	  - 用双括号括起来的内容被视为指向该字符串存储位置的指针。
	
	    ```c
	    printf("%s, %p, %c\n", "We", "are", *"space farers");
	    // 输出：We \, 0x100000f61, s
	    ```
	
	- 指针表示法
	
	  ```c
	  const char ar1[] = "Something.";
	  const char * pt1[] = "Something.";
	  ```
	
	  以上两个声明表明，pt1和ar1都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。
	
	- 字符串数组形式和指针形式的区别 **详见教材P277**
	  - 程序载入内存时，字符串被载入并存储在静态存储区中。**初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。** 初始化完成后，指针名的地址和字符串常量相同，而数组名的地址是不同的新地址。
	
	  - 字符串数组是可修改的（除非为const），但无法通过字符串指针修改字符串常量。
	
	  - 字符串数组的元素是变量，但**数组名是常量**；指向字符串的**指针名是变量**。例如：
	
	    ```c
	    char arr[] = "Wow~";
	    char *pt = "Wow~";
	    ```
	
	    两者都可以使用数组表示法，都可以进行指针加法；只有指针表示法可以递增；一般来说，只对数组表示法的字符串进行修改。
	    应注意的是，虽然因编译器不同有所差别，但不应该通过指针修改字符串。建议在把指针初始化为字符串常量时使用const限定符。**经实测，GCC编译器中字符串常量为const类型，存储在静态存储区，不可通过指针修改。**
	
	    ```c
	    pt[0] = ’C‘;// 不推荐，实测不可行（Segmentation Fault）
	    const char *p1 = "Wow~";// 推荐用法
	    ```

- 字符串数组
  方式同样有数组表示法和指针表示法。

  ```c
  const char *sp[3] = { "Sun", "Yah", "Sen" };// 内含3个指针的数组，占用40字节。指向初始化时所用的字符串字面量的位置，字符串字面量存储在静态内存中
  char sa[3][3] = { "Sun", "Yah", "Sen" };// 内含3个数组的数组，每个数组3个char类型的值，共占用9字节。数组存储了字符串字面量的副本。
  ```

比较而言，指针数组效率更高，分配的内存少，但指向的字符串字面量无法修改；如果要改变字符串或为字符串输入预留空间，应使用char类型二维数组。
- 字符串输入
	- gets()函数
	- fgets()函数
	注意，读到换行符时，gets()会丢弃，而fgets会保留。相应地，puts()会在待输出字符串末尾添加一个换行符，而fputs()不会。
	 - 删除换行符与丢弃缓存区多余字符
	
- 字符串输出
	- puts()
	
	  C 库函数 **int puts(const char \*str)** 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。
	
	- fputs()
	
	  C 库函数 **int fputs(const char \*str, FILE \*stream)** 把字符串写入到指定的流 stream 中，但不包括空字符。
	
	  
### （四）存储类别、链接和内存管理
- 存储类别
	- 对象是存储的值占用的一块物理内存。
	- 作用域：块作用域、函数作用域、（内部链接/外部链接的）文件作用域（全局）。
	- 链接：内部链接(static声明)和外部链接。
	- 存储期：静态、线程、自动、动态分布。
	
- 分配内存：malloc()和free()
	- malloc()分配未赋名的内存，返回动态分配内存块的首字节地址。可以把该地址赋给一个指针变量，并使用指针访问这块内存。
	
	  ```c
	  int n;
	  double * ptd;
	  ptd = (double *) malloc(n * sizeof(double));// 创建动态数组
	  ```
### （五）文件输入/输出
- 标准I/O
	- 检查命令行参数
	
	- fopen()和fclose()
	
	  C 库函数 **FILE \*fopen(const char \*filename, const char \*mode)** 使用给定的模式 **mode** 打开 **filename** 所指向的文件。
	
	  | 模式 | 描述                                                         |
	  | :--- | :----------------------------------------------------------- |
	  | "r"  | 打开一个用于读取的文件。该文件必须存在。                     |
	  | "w"  | 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 |
	  | "a"  | 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 |
	  | "r+" | 打开一个用于更新的文件，可读取也可写入。该文件必须存在。     |
	  | "w+" | 创建一个用于读写的空文件。                                   |
	  | "a+" | 打开一个用于读取和追加的文件。                               |
	
	  C 库函数 **int fclose(FILE \*stream)** 关闭流 stream。刷新所有的缓冲区。
	
	- getc()和putc()
	
	  C 库函数 **int getc(FILE \*stream)** 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
	
	  C 库函数 **int putc(int char, FILE \*stream)** 把参数 **char** 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
	
	- 文件读取范例
	
	  ```c
	  int ch;
	  FILE *fp;
	  fp = fopen("wenben.txt","r");
	  while (( ch = getc(fp)) != EOF)
	  {
	  	putchar(ch);
	  }
	  ```
	  
	- 指向标准文件的指针：stdin、stdout和stderr
	
- 文件I/O：fprintf()、fscanf()、fgets()和fputs()

  C 库函数 **int fprintf(FILE \*stream, const char \*format, ...)** 发送格式化输出到流 stream 中。

  | specifier（说明符） | 输出                                      |
  | :------------------ | :---------------------------------------- |
  | c                   | 字符                                      |
  | d 或 i              | 有符号十进制整数                          |
  | e                   | 使用 e 字符的科学科学记数法（尾数和指数） |
  | E                   | 使用 E 字符的科学科学记数法（尾数和指数） |
  | f                   | 十进制浮点数                              |
  | g                   | 自动选择 %e 或 %f 中合适的表示法          |
  | G                   | 自动选择 %E 或 %f 中合适的表示法          |
  | o                   | 有符号八进制                              |
  | s                   | 字符的字符串                              |
  | u                   | 无符号十进制整数                          |
  | x                   | 无符号十六进制整数                        |
  | X                   | 无符号十六进制整数（大写字母）            |
  | p                   | 指针地址                                  |
  | n                   | 无输出                                    |
  | %                   | 字符                                      |

  | flags（标识） | 描述                                                         |
  | :------------ | :----------------------------------------------------------- |
  | -             | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |
  | +             | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |
  | (space)       | 如果没有写入任何符号，则在该值前面插入一个空格。             |
  | #             | 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |
  | 0             | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |

  | width（宽度） | 描述                                                         |
  | :------------ | :----------------------------------------------------------- |
  | (number)      | 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 |
  | *             | 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

  | .precision（精度） | 描述                                                         |
  | :----------------- | :----------------------------------------------------------- |
  | .number            | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 |
  | .*                 | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

  | length（长度） | 描述                                                         |
  | :------------- | :----------------------------------------------------------- |
  | h              | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 |
  | l              | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |
  | L              | 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 |

  - **附加参数** -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。

  C 库函数 **char \*fgets(char \*str, int n, FILE \*stream)** 从指定的流 stream 读取一行，并把它存储在 **str** 所指向的字符串内。当读取 **(n-1)** 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。

  C 库函数 **int fputs(const char \*str, FILE \*stream)** 把字符串写入到指定的流 stream 中，但不包括空字符。
### （六）结构和其他数据形式
- 建立结构声明

- 定义结构变量
	注意，结构标记是可选的。若声明结构只用来定义一个结构变量，结构标记可以省略；若打算多次使用结构模板，则必须使用带标记的结构声明。
	- 初始化结构
	- 访问结构成员
	
	```c
	struct book{
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	};// 带标记“book”的结构声明
	struct book library;// 定义结构变量
	
	struct book{
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	} library;// 声明结构并定义结构变量
	
	struct {
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	} library;// 一次性声明结构并定义结构变量
	```
	
- 结构数组
	- 声明结构数组
	- 读取结构数组
	
- 嵌套结构
	- 传递结构成员
	- 传递结构的地址
	- 传递结构
	```c
	struct names {
	char first[LEN];
	char last[LEN];
	};
	
	struct student {
		struct names handle;
		char food[LEN];
		char job[LEN];
		float income;
	};
	struct student fellow= {
		{ "Mingyang", "Guo"},
		"Banana",
		"Student",
		114514.00
	};
	
	printf("%s's income is %f",fellow.handle.first,fellow.income);

- 结构/结构指针的双向通信

- 结构和结构指针的选择：传递结构指针更高效，传递结构多用于小型结构。

- 把结构内容保存到文件中【待复习】

- 链式结构

- 联合

- 枚举类型

  枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。，它可以让数据更简洁，更易读。

  枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。

  定义一个枚举类型，需要使用 **enum** 关键字，后面跟着枚举类型的名称，以及用大括号 **{}** 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 **0** 开始递增。

  枚举语法定义格式为：

  ```c
  enum　枚举名　{枚举元素1,枚举元素2,……};
  ```

- typedef
	- typedef为某一类型自定义名称，由编译器解释。
	- typedef和#define的区别
	
	C 语言提供了 **typedef** 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 **BYTE**：
	
	```c
	typedef unsigned char BYTE;
	```
### （七）高级数据类型
- 链表
	- 显示链表
	- 创建链表
	- 释放链表
