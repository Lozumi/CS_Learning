### 题目

给定一个最小堆，按先序遍历输出堆中的元素。输入是一个不大于 100 的正整数 `n`，表示堆中的元素个数，以及按从小到大的次序的 `n` 个元素（即最小堆的元素）。输出为二叉树先序遍历的结果，元素之间用空格隔开。

### 示例

#### 输入
```
5
10 20 30 40 50
```

#### 输出
```
10 20 40 50 30 
```

### 分析

在最小堆中，对于给定索引 `i` 的节点：
- 父节点的索引为 `(i - 1) / 2` (数组从0开始)
- 左子节点的索引为 `2 * i + 1`
- 右子节点的索引为 `2 * i + 2`

先序遍历的顺序是：访问根节点 -> 递归遍历左子树 -> 递归遍历右子树。

### 解答

```c
#include <stdio.h>
#define MAX 100

// 先序遍历函数
void preOrder(int heap[], int n, int index) {
    if (index >= n) {
        return;
    }

    // 先访问根节点
    printf("%d ", heap[index]);

    // 递归地访问左子树
    preOrder(heap, n, 2 * index + 1);

    // 递归地访问右子树
    preOrder(heap, n, 2 * index + 2);
}

int main() {
    int n;
    
    // 读取节点数量
    scanf("%d", &n);

    int heap[MAX];

    // 读取堆中的元素
    for (int i = 0; i < n; i++) {
        scanf("%d", &heap[i]);
    }

    // 进行先序遍历
    preOrder(heap, n, 0);

    return 0;
}
```

### 代码说明

1. **定义常量 `MAX`**：定义了一个常量 `MAX`，表示堆的最大元素个数为 100。
2. **先序遍历函数 `preOrder`**：该函数接受一个堆数组、元素个数和当前节点索引作为参数，并递归地进行先序遍历。
   - 如果当前节点索引超出了堆的范围，函数直接返回。
   - 首先访问当前节点并打印它的值。
   - 递归调用 `preOrder` 函数访问左子树和右子树。
3. **主函数 `main`**：
   - 读取堆中元素的个数 `n`。
   - 读取堆中的元素并存入数组 `heap` 中。
   - 调用 `preOrder` 函数，从根节点（索引为 0）开始进行先序遍历。

### 输入输出示例

**输入：**
```
5
10 20 30 40 50
```

**输出：**
```
10 20 40 50 30 
```

### 解释

对于输入的堆 `10 20 30 40 50`，其对应的二叉树结构为：
```
      10
     /  \
   20    30
  /  \
40   50
```
先序遍历结果依次为：根节点 10，左子树的根 20，左子树的左子节点 40，左子树的右子节点 50，最后是右子树的根 30。