### 实验题目: 高精度计算Pi值

### 实验目的：
- 理解和掌握双向链表数据结构的特性和操作。
- 学习和实践高精度计算Pi值的算法。
- 提高分析问题和解决问题的能力。

### 实验内容：
- 设计并实现一个程序，该程序能够使用双向链表作为存储结构，高精度计算圆周率Pi的值。
- 根据用户输入的精度要求，计算并输出Pi值。

## 一、需求分析
本程序设计的任务是使用双向链表实现高精度的Pi值计算。程序需要接收用户输入的精度要求，然后输出计算得到的Pi值。具体要求如下：

1. 输入的形式和输入值的范围：
   - 输入一个正整数n，表示要求精确到小数点后的位数（1 ≤ n ≤ 500）。

2. 输出的形式：
   - 输出Pi的值，精确到小数点后n位，最后输出一个回车。

3. 程序所能达到的功能：
   - 根据用户输入的精度要求，计算并输出Pi值。
   - 处理用户输入，包括异常输入的检测和处理。

4. 测试数据：

   - 测试用例一：

     - 输入：

       ```text
       10
       ```

     - 预期输出：

       ```text
       3.1415926531
       ```

   - 测试用例二：

     - 输入：

       ```text
       100
       ```

     - 预期输出：

       ```text
       3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
       ```

   - 测试用例三：

     - 输入：

       ```text
       500
       ```

     - 预期输出：

       ```text
       3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912
       ```

   - 测试用例四：

     + 输入：

       ```text
       0
       ```

       

     - 预期输出：

       ```text
       3
       ```

   - 测试用例五：（错误输入）

     - 输入：

       ```
       -1
       ```

     - 输出：

       ```
       输入精度应为正整数！
       ```

- ### 二、概要设计

  在概要设计部分，我们将概述高精度计算Pi值程序的主要组件和它们之间的关系。程序的设计基于以下几个关键模块：

  1. **输入模块**：负责接收用户输入的精度要求，并进行有效性验证。确保输入是一个正整数，这是计算Pi值所必需的。

  2. **初始化链表模块** (`initializeList`)：创建一个基本的双向链表结构，该结构将用于存储计算过程中的数字。链表的初始状态包含单个节点，其值为2，这是莱布尼茨级数公式的基础。

  3. **扩展链表模块** (`extendList`)：根据所需的精度，扩展链表以容纳更多的数字。通过在链表末尾添加新的节点，确保有足够的空间存储计算结果。

  4. **链表乘法模块** (`multiplyList`)：实现链表与整数的乘法操作。这是计算过程中的一个关键步骤，用于生成莱布尼茨级数的每项。

  5. **链表除法模块** (`divideList`)：实现链表与整数的除法操作。这同样是一个关键步骤，用于计算每项的商，并为下一项的计算做准备。

  6. **链表相加模块** (`addList`)：实现两个链表的相加操作。在计算莱布尼茨级数的每一项后，需要将结果累加到当前的总和中。

  7. **打印链表模块** (`printList`)：负责将链表中的数字以指定的精度打印出来。这将输出计算得到的Pi值。

  8. **销毁链表模块** (`destroyList`)：在计算完成后，释放链表所占用的内存资源，确保程序不会泄露内存。

  这些模块的协同工作流程如下：

  - 用户输入精度要求。
  - 程序初始化链表，并根据精度要求扩展链表。
  - 程序使用莱布尼茨级数公式计算Pi值的每一项。
  - 每计算出一项，程序就将其乘以相应的因子，除以分母，然后累加到总和中。
  - 计算完成后，程序打印出精确到用户指定小数位数的Pi值。
  - 最后，程序释放所有分配的内存资源。


## 三、详细设计
1. 双向链表节点类型和指针类型：
   ```c
   typedef struct Node {
       int data; // 存储节点的数据
       struct Node *prev; // 指向前一个节点的指针
       struct Node *next; // 指向下一个节点的指针
   } Node, *LinkedList;
   ```
2. 每个模块的分析：

   + 初始化链表模块 (`initializeList`)

     此模块负责创建并初始化一个双向链表，链表的第一个节点存储数字2，同时该节点的`prev`和`next`指针指向自身，表示链表中只有一个节点。

   ```c
   LinkedList initializeList() {
       LinkedList list = (LinkedList)malloc(sizeof(Node));
       if (list == NULL) {
           // 内存分配失败的处理
           exit(EXIT_FAILURE);
       }
       list->data = 2;
       list->prev = list;
       list->next = list;
       return list;
   }
   ```

   + 扩展链表模块 (`extendList`)

     此模块用于在链表的末尾添加新的节点，每个新节点存储数字0。通过循环调用此函数，可以扩展链表以存储更多的数字。


   ```c
   void extendList(LinkedList list, int data) {
       LinkedList tmp = list;
       tmp = tmp->prev; // 移动到最后一个节点
       LinkedList newNode = (LinkedList)malloc(sizeof(Node));
       if (newNode == NULL) {
           // 内存分配失败的处理
           exit(EXIT_FAILURE);
       }
       newNode->data = data;
       newNode->next = tmp->next; // 新节点的下一个节点是原链表的第一个节点
       newNode->prev = tmp; // 新节点的前一个节点是原链表的最后一个节点
       tmp->next->prev = newNode; // 更新原链表第一个节点的前一个节点指针
       tmp->next = newNode; // 更新原链表最后一个节点的下一个节点指针
   }
   ```

   + 链表乘法模块 (`multiplyList`)

     此模块实现了链表与一个整数的乘法操作。它遍历链表的每个节点，将节点的值与整数相乘，并处理进位。


   ```c
   void multiplyList(LinkedList list, int factor) {
       int carry = 0;
       LinkedList p = list->prev;
       while (p != list) {
           int tmp = p->data * factor + carry;
           p->data = tmp % 10;
           carry = tmp / 10;
           p = p->prev;
       }
       if (carry > 0) { // 如果存在进位，添加一个新的节点
           extendList(list, carry);
       }
   }
   ```

   + 链表除法模块 (`divideList`)

     此模块实现了链表与一个整数的除法操作。它从链表的第一个节点开始，逐个计算商和余数，更新节点的值。


   ```c
   void divideList(LinkedList list, int divisor) {
       int remainder = 0;
       LinkedList p = list;
       while (p != list) {
           int tmp = p->data + remainder * 10;
           remainder = tmp % divisor;
           p->data = tmp / divisor;
           p = p->next;
       }
       if (p->data == 0) { // 如果最后一个节点的值为0，删除该节点
           list->prev = p->prev;
           list->prev->next = p->next;
           free(p);
       }
   }
   ```

   + 链表相加模块 (`addList`)

     此模块实现了两个链表的相加操作。它遍历两个链表，逐个计算对应节点的和，包括进位，并更新节点的值。


   ```c
   void addList(LinkedList list1, LinkedList list2) {
       int carry = 0;
       LinkedList p1 = list1->prev, p2 = list2->prev;
       while (p1 != list1->prev || p2 != list2->prev) {
           int sum = (p1 ? p1->data : 0) + (p2 ? p2->data : 0) + carry;
           if (p1) p1->data = sum % 10;
           if (p2) p2->data = sum % 10;
           carry = sum / 10;
           if (p1 && p1->prev == list1) break; // 如果到达链表1的末尾，结束循环
           p1 = p1->prev;
           p2 = p2->prev;
       }
       if (carry > 0) { // 如果存在进位，添加一个新的节点
           extendList(list1, carry);
       }
   }
   ```

   + 打印链表模块 (`printList`)

     此模块负责打印链表表示的数字，保留指定的小数位数。它从链表的第一个节点开始，打印每个节点的值，直到达到指定的小数位数。


   ```c
   // 打印链表函数
   void printList(LinkedList list, int decimalPlaces) {
       // 打印链表表示的数字，保留指定的小数位数
       LinkedList p = list; // 从链表的第一个节点开始
       if (decimalPlaces == 0)
           printf("%d", p->data); // 打印小数点前的数字
       else{
           printf("%d.", p->data); // 打印小数点前的数字
           p = p->next; // 移动到小数点后的节点
           for (int i = 0; i < decimalPlaces; i++) { // 打印小数点后的数字
               printf("%d", p->data);
               p = p->next; // 移动到下一个节点
           }
           printf("\n"); // 打印换行符
       }
   }
   ```

   + 销毁链表模块 (`destroyList`)

     此模块负责释放链表所占用的内存。它遍历链表，释放每个节点，最后释放链表的头节点。


   ```c
   void destroyList(LinkedList list) {
       LinkedList tmp = list->next;
       while (tmp != list) {
           list->next = tmp->next;
           free(tmp);
           tmp = list->next;
       }
       list->prev = list;
       free(list);
       list = NULL;
   }
   ```

3. 完整的程序：
   ```c
   // 见源文件
   ```

## 四、使用说明、测试分析及结果
1. 程序使用说明：
   - 程序的运行环境为GCC编译器。
   - 用户根据提示输入精度要求，程序将自动计算并输出Pi值。

2. 测试结果与分析：

   - 测试用例一：

     - 输入：

       ```text
       10
       ```

     - 预期输出：

       ```text
       3.1415926531
       ```

   - 测试用例二：

     - 输入：

       ```text
       100
       ```

     - 输出：

       ```text
       3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
       ```

   - 测试用例三：

     - 输入：

       ```text
       500
       ```

     - 输出：

       ```text
       3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912
       ```

   - 测试用例四：

     + 输入：

       ```text
       0
       ```

       

     - 输出：

       ```text
       3
       ```

   - 测试用例五：（错误输入）

     - 输入：

       ```
       -1
       ```

     - 输出：

       ```
       输入精度应为正整数！
       ```

3. 调试过程中遇到的问题及解决办法：
   - 问题：用户可能输入负数的精度要求。
     解决办法：在输入模块中添加对精度要求的验证。
     
   - 问题：用户可能输入0位的精度要求。

     解决办法：增加判断条件，特殊处理输出。

4. 运行界面：
   - 程序启动后，首先提示用户输入精度要求，然后输出计算得到的Pi值。

## 五、实验总结
- 在编程过程中，我花费了约3小时完成程序设计和编码。
- 纸上设计耗时约1.5小时，上机输入和调试耗时约1小时，思考问题耗时约0.5小时。
- 遇到的难题主要是如何使用双向链表实现计算算法，如何实现指定精度。
- 我加深了对双向链表数据结构的理解，学会了基于双向链表结构的四则运算。