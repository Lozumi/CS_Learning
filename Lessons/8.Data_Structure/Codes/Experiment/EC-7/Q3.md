### 实验题目: 用弗洛伊德算法求赋权图的两点间的最短路径的长度

### 实验目的

- 理解弗洛伊德（Floyd）算法的工作原理。
- 掌握在赋权图中求解所有顶点对之间最短路径的方法。
- 提升解决复杂图论问题的能力。

### 实验内容

实现弗洛伊德算法求解图中所有顶点对的最短路径。

**输入要求**：

- 图中顶点的数量，正整数。
- 图的邻接矩阵，表示顶点间的连接关系和权重。

**输出要求**：

- 所有顶点对之间的最短路径长度。

**功能要求**：

- 能够处理包含负权边的图，但不处理负权环。
- 输出所有顶点对的最短路径长度。

测试输入

```
4
0 1 3 2
1 0 10000 4
10000 10000 0 2
3 2 0 0
3
0 2
1 3
2 0

```

测试输出

```
3
6
6
```



### 实验分析

弗洛伊德算法是一种动态规划算法，用于找到给定加权图中所有顶点对之间的最短路径。算法的基本思想是通过引入中间顶点逐步改进路径。具体来说，如果通过顶点`k`可以缩短从顶点`i`到顶点`j`的路径，那么更新路径为`distance[i][j] = distance[i][k] + distance[k][j]`。

**步骤如下**：

1. 初始化：从输入读取图的邻接矩阵，并初始化距离矩阵。
2. 动态规划：逐步引入中间顶点，更新每一对顶点之间的最短路径。
3. 输出结果：根据更新后的距离矩阵，输出指定的顶点对之间的最短路径。

**算法复杂度**：

- 时间复杂度：`O(n^3)`，其中`n`是顶点的数量。由于三重循环，每个循环遍历所有顶点。
- 空间复杂度：`O(n^2)`，用于存储距离矩阵。

### 解决方案

**定义数据结构**：

- 使用二维数组`distance`来存储顶点之间的距离。

**实现Floyd算法**：

- 三重循环实现动态规划，逐步引入中间顶点更新最短路径。

**读取输入并打印输出**：

- 读取图的邻接矩阵。
- 调用Floyd算法计算最短路径。
- 根据用户查询输出对应顶点对之间的最短路径。

### 代码

```c
// DS Exp EC-7
// 20240526 刘黎可

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 105
#define INF 10000 // 定义一个代表无穷大的值，用于初始化距离矩阵

int distance[MAX_SIZE][MAX_SIZE];

// Floyd算法计算所有顶点对之间的最短路径
void floyd(int n) {
    int i, j, k;
    // 读入邻接矩阵
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            scanf("%d", &distance[i][j]);
            if (i != j && distance[i][j] == 0) {
                distance[i][j] = INF; // 将无直接连接的边初始化为无穷大
            }
        }
    }
    // Floyd算法更新最短路径
    for (k = 1; k <= n; k++) {
        for (i = 1; i <= n; i++) {
            for (j = 1; j <= n; j++) {
                if (distance[i][j] > distance[i][k] + distance[k][j]) {
                    distance[i][j] = distance[i][k] + distance[k][j];
                }
            }
        }
    }
}

// 打印顶点对之间的最短路径长度
void print_distances(int m) {
    int i, x, y;
    scanf("%d", &m); // 读入需要查询的路径对数
    int temp[MAX_SIZE];
    for (i = 1; i <= m; i++) {
        scanf("%d %d", &x, &y); // 读入查询的两个顶点
        temp[i] = distance[x + 1][y + 1]; // 存储最短路径长度
    }
    for (i = 1; i <= m; i++) {
        printf("%d\n", temp[i]); // 输出最短路径长度
    }
}

int main() {
    int n, m;
    scanf("%d", &n); // 读入顶点数
    floyd(n); // 计算最短路径
    print_distances(m); // 打印结果
    return 0;
}

```

